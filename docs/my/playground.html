<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>A Basic Vue Playground</title>
    <script src="https://cdn.bootcss.com/vue/2.6.10/vue.js"></script>
  </head>
  <body>
    <div id="app"></div>

    <div id="counter">
      <p>{{ counter }}</p>
      <button @click="counter++" ref="btn2">press me</button>
      <p>{{ oddOrEven }}</p>
      <my-btn msg="my btn 123"></my-btn>
    </div>

    <script>
      var MyBtn = Vue.component("MyBtn", {
        name: "MyBtn",
        props: ["msg"],
        template: '<button @click="btnClicked" ref="btn1">{{ msg }}</button>',
        methods: {
          btnClicked() {
            console.log("my btn clicked", this.msg);
          }
        }
      });

      var vm = new Vue({
        el: "#counter",
        data() {
          return {
            counter: 0,
            oddOrEven: "even"
          };
        }
      });
    </script>

    <script>
      // var vm = new Vue({
      //   el: '#counter',
      //   directives: {
      //     // focus: {
      //     //   inserted: function(el) {
      //     //     console.log('directive-focus-inserted', el)
      //     //     el && el.focus()
      //     //   }
      //     // }
      //     focus: function(el) {
      //       // 如果focus是个function，那么只会{ bind: focus, update: focus }这样，在inserted的时候是不调用的。
      //       // 与上面的focus例子做对比也可以看出来，这里的focus只有页面update重新渲染时，input才会自动focus。
      //       console.log('directive-focus', el);
      //       el && el.focus();
      //     }
      //   },
      //   data() {
      //     return {
      //       counter: 0
      //     }
      //   },
      //   mounted() {
      //     console.log('vm mounted')
      //   }
      // })

      // // console.log('Vue.options', Vue.options)
      // // console.log('vm.options', vm.$options)
      // // console.log('vm.constructor.options', vm.constructor.options)
      // var opt = Object.create(vm.constructor.options)
      // // console.log('opt', opt)
    </script>

    <script>
      function Person(name) {
        this.name = name;
      }

      var p = new Person("mike");
      // console.log(p.constructor)
      // console.log(Person.prototype)
      // console.log(Person.prototype.constructor === p.constructor)

      var a = new p.constructor("dave");
      // console.log(a)
    </script>

    <script>
      function toArray(list, start = 0) {
        start = start || 0;
        let i = list.length - start;
        const ret = new Array(i);
        while (i--) {
          ret[i] = list[i + start];
        }
        return ret;
      }

      var arr = [0, 1, 2, 3, 4];
      var _arr = toArray(arr, 2);
    </script>

    <script>
      var a = {
        msg: "hello"
      };

      function handler(obj) {
        obj = Object.assign({}, obj, {
          age: 18
        });
        return obj;
      }

      function changer(obj) {
        obj.msg = "world";
        return obj;
      }

      var b = handler(a);
      // console.log(a) // {msg: "hello"}
      // console.log(b) // {msg: "hello", age: 18}
      var c = changer(a);
      // console.log(a) // {msg: "world"}
      // console.log(c) // {msg: "world"}
    </script>

    <script></script>
  </body>
</html>
