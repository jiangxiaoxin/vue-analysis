在《深入响应式原理》里，完成通知的是靠`Publisher-Subscriber`**发布-订阅**模式。很多地方说到一个观察者模式`Observer Design Pattern`,这两个模式其实不是一个模式，只是有些类似的地方。

### 相同

两种模式的目的是一致的，都是为了实现一种机制：当一个“事件”发生后，对这个“事件”敏感的“对象”会发觉并做出响应。

### 不同

观察者模式由两部分组成，`Subject`和`Observer`。简单的描述就是，`Subject`里有一个数组，存放的就是对它“敏感”的`Observer`们的引用,当发生事件需要通知到到观察者时，`Subject`会调用自己的`notify`方法，然后逐一执行观察者们统一的方法`update`,这样子观察者就对事件作出了响应。

发布-订阅模式完成的功能与此类似，但组成明显不同。`Publisher`发出事件，它只关心完成这一部分功能，发出之后就不管了。`Subscriber`只关心已经表示要订阅某个事件了，其余的不关心。真正串联起来这两端的是中间的控制中心`event bus`。由控制中心去记录谁订阅了什么事件，在事件发出后，由控制中心去通知订阅者。

在观察者模式中，组成系统的两端是强耦合的，谁都知道谁。在发布-订阅模式中，系统的两端是松耦合的，两端之间没有直接的联系，而是通过中间的控制中心去关联功能。

在`_init`方法里执行`initLifecycle`时`vm._watcher = null`,也就是Vue实例在创建的一开始是没有对应的`Watcher`的。`Watcher`就是“监视”行为的中间人，这个`Vue`实例把监视和更新交给了第三者`Watcher`,这也就是上面说的`Vue`用的是`Publisher-Subscriber`模式，用中间人代理互动，而不是直接的`Observer pattern`。一个对象的某个值对应一个`Dep`实例，这个`Dep`实例会搜集所以对它感兴趣的`Watcher`实例，当这个值发生变化时，会调用`Watcher`的`update`对象，进而调用实例化`Watcher`时传入的更新方法，更新对这个对象“感兴趣”的另外那个实例

> 一个`dep`可以有多个`watcher`关注着它，一个`watcher`也可以对多个`dep`感兴趣.